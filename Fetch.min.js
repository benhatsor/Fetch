class Fetch{defaults={responseType:["json","text"],onlyBody:!0};methods=["GET","HEAD","POST","PUT","DELETE","CONNECT","OPTIONS","TRACE","PATCH"];constructor(){this.methods.forEach(t=>{this[t=t.toLowerCase()]=this.getMethod(t)})}getMethod(t){return t=t.toUpperCase(),(e,s={})=>(s.method=t,this.fetch(e,s))}async fetch(t,e={}){let{isString:s,coerceValueToString:i}=this.util,o=e.prefix;"prefix"in e&&s(o)&&s(t)&&(t=i(t),t=(o=i(o))+t);let r=fetch(t,e),a=await r;for(option in this.defaults)option in e||(e[option]=this.defaults[option]);return(await this.parseRespBody(a,e.responseType),e.onlyBody)?a.body:a}async parseRespBody(t,e){let{isValidFunction:s,setReadOnlyProp:i}=this.util;if(Array.isArray(e)){if(0!==e.length){let o=await this.parseRespBody(t,e[0]);return o||(e.shift(),await this.parseRespBody(t,e))}}else if(s(e,t)){let r=t[e],a;try{a=await r.call(t)}catch(n){return}return i(t,"body",a),!0}}util={isValidFunction:(t,e)=>t in e&&"function"==typeof e[t],setReadOnlyProp(t,e,s){Object.defineProperty(t,e,{value:s})},isString:t=>"[object String]"===Object.prototype.toString.call(t),coerceValueToString:t=>`${t}`}}Fetch=new Fetch;
