class Fetch{fetchOptions={defaultResponseType:["json","text"]};methods=["GET","HEAD","POST","PUT","DELETE","CONNECT","OPTIONS","TRACE","PATCH"];constructor(){this.methods.forEach(e=>{this[e=e.toLowerCase()]=this.getMethod(e)})}getMethod(e){return e=e.toUpperCase(),(t,s={})=>(s.method=e,this.fetch(t,s))}async fetch(e,t){let{isString:s,coerceValueToString:i}=this.util,o=t.prefix;"prefix"in t&&s(o)&&s(e)&&(e=i(e),e=(o=i(o))+e);let r=fetch(e,t),a=await r;return("responseType"in t?await this.parseRespBody(a,t.responseType):await this.parseRespBody(a,this.fetchOptions.defaultResponseType),!1!==t.onlyBody)?a.body:a}async parseRespBody(e,t){let{isValidFunction:s,setReadOnlyProp:i}=this.util;if(Array.isArray(t)){if(0!==t.length){let o=await this.parseRespBody(e,t[0]);return o||(t.shift(),await this.parseRespBody(e,t))}}else if(s(t,e)){let r=e[t],a;try{a=await r.call(e)}catch(n){return}return i(e,"body",a),!0}}util={isValidFunction:(e,t)=>e in t&&"function"==typeof t[e],setReadOnlyProp(e,t,s){Object.defineProperty(e,t,{value:s})},isString:e=>"[object String]"===Object.prototype.toString.call(e),coerceValueToString:e=>`${e}`}}Fetch=new Fetch;
